#!/usr/bin/perl
# Monitors nvidia-smi GPU temperature output.
# Sets fan speed.
#
# DANGER DANGER DANGER!
# Using your own fan control, especially one monitored by a user process,
# even as root, is risky.  You might even get values wrong.
# You might cook your card or mess up some other fan or damage your system.
#
# By using this software you accept all responsibility and liability for
# damages and hold the author(s) free from all claims.
# The software is for educational purposes only and you should not use it
# unless you know what you are doing!
#
# Values given are in Centigrade
# Writes abundant info to output (stdout)
# Log-worthy information goes to stderr, thus, you can >/dev/null for minimal output
# Configure with sections below

# Usage:
# Editing config variables below:
# Then pick one of 4 options:
# 1. LEAST PREFERRED, but fine for testing:
#    Run it yourself with: sudo ./k80-fan-control
#    (it needs access to write to the pwm control files)
# 2. MOST PREFERRED FOR RELIABILITY: Run as root:
#  2a. Using:       crontab -e as root:
#    m   h dom mon dow  command
#    */5 * *   *   *    /path/to/nvidia-k80-fan/k80-fan-control >/dev/null
#  2b. Or editing:  /etc/crontab
#    m   h dom mon dow user  command
#    */5 * *   *   *   root  /path/to/nvidia-k80-fan/k80-fan-control >/dev/null
# 3. Figure out how to get your user access to the sys pwm files
#    This is not preferred anyway, in my opinion, because a change to those
#    files might suddenly result in your user not having permission to set
#    the fan, resulting in damage to your card.
die "We're not going to run unless you read the disclaimer\n" .
    " (found in this file)," .
    "accept the release of liability,\n" .
    "and maybe testify that you're careful enough to do this.\n" .
    "Oh, and then comment out this die() message.";
use warnings; use strict;
use IO::Select qw();
$!=1;

#########################################################################
#  MAIN CONFIG
#  1. Pick your pwm devices to control fan speed
#     Make sure lm-sensors is installed
#     Run: sensors -u to find your fan, then check these dirs \/ \/
#  2. We use pwm_fn for setting the actual pwm value
#  3. We use pwm_enable_fn, which selects manual or auto mode or whatever
#     (We set it to 1 to enable manual mode)
my $pwm_fn        = "/sys/class/hwmon/hwmon2/pwm4";
my $pwm_enable_fn = "/sys/class/hwmon/hwmon2/pwm4_enable";

my $expected_gpu_count=3; # We currently get all GPU temps, but later we
                          #  might change to just asking for the ones we want
my @gpuids=(1,2);  # ids of interest from nvidia (to check their temperatures)
                   # (indexes, 0... into the returned list from nvidia-smi)
                   # So, we are reading 3 values, and ignoring the first,
                   #  taking only the [1] and [2]. We check for the max temp
                   #  and set the PWM based on it.
                   # At present we load all GPU temps, but nvidia-smi -i
                   # takes comma-separated list too apparently

#########################################################################
#  LESS NEEDY CONFIG (but note that maxtemp is when pwm will be at max)
#  (These should be safe defaults, but do look at mintemp/maxtemp)
#  1. At mintemp, the fan's PWM value will be set to minpwm
#  2. It will increase linearly, up to maxpwm, until maxtemp
my $delay=3;       # (s) between checks of GPU temperatures (ints)
my $timeout=5;     # (s) for safety, if we pass this nvidia-smi will be restarted
my $minpwm = 69;
my $maxpwm = 255;
my $mintemp = 33;
my $maxtemp = 45;  # See section description above
my $verbose = 0;
# Some assertions for configured values:
die "Timeout ($timeout) must be larger than delay ($delay)!!" if $timeout <= $delay;
die "Minpwm ($minpwm) must be less than maxpwm ($maxpwm)!!" if $minpwm >= $maxpwm;
die "Mintemp ($mintemp) must be less than maxtemp ($maxtemp)!!" if $mintemp >= $maxtemp;
#export s0='stdbuf -i0 -o0'

# Internal
my $smif;          # nvidia-smi file "descriptor".. run running it
my $smicmd="nvidia-smi --loop='$delay' --format=noheader,nounits,csv --query-gpu=temperature.gpu";
my $last_pwm=-1;    # value of last pwm setting we wrote

my $our_name = get_our_name($0);  # process name for preventing duplicate runs
check_competing_processes();

# Colors!
my $bred = "\033[31;1m";
my $yel = "\033[33;1m";
my $rst = "\033[0m";
my $bcya = "\033[36;1m";
my $whi = "\033[37;1m";

#$s0 nvidia-smi -l -q -d temperature -i 0 | $s0 grep -i 'GPU.Current.Temp' | $s0 sed -e 's/^.*: //; s/ C.*//'
#echo 'nvidia-smi --loop="$delay" --format=noheader,nounits,csv --query-gpu=temperature.gpu -i "$gpuid"'
#nvidia-smi --loop="$delay" --format=noheader,nounits,csv --query-gpu=temperature.gpu -i "$gpuid"

sub set_max { # Set fan to max speed
}

sub get_our_name {
	my $zero = shift;
	$zero =~ s#^.*/##;
	$zero;
}

sub find_competing_processes {
	my @procs = `pgrep '$our_name'`;
}

sub check_competing_processes {
	my @procs = find_competing_processes();
	if (@procs > 1) {
		die "Another one of us ($our_name) is running. Modify me to allow this.";
	}
}


sub failure { # This is bad
	# prints time, message, and sets max fan speed (unless setmax is set to 0)
	# failure("message")
	# failure("message", setmax=>0)
	my $msg = shift;
	my %opts = @_;
	my $setmax = $opts{setmax} // 1;  # setmax=>1 (default) sets max fan speed
	warn sprintf("${bred}[%s] $msg$rst", timestr_short());
	set_max() if $setmax;
}

sub pstderr {
	# prints time, message
	# log("message")
	# log("message", color=>$bred)            # ansi color
	# log("message", color=>$bred, indent=>2) # 2 spaces before
	my $msg = shift;
	my %opts = @_;
	my $color = $opts{color} // "";  # setmax=>1 (default) sets max fan speed
	my $indent = $opts{indent} // 0; # indent line this many spaces
	my $reset = $color ne "" ? $rst : "";
	print STDERR sprintf("${color}[%s] %*s$msg$reset\n",
		timestr_short(),
		$indent, "",
	);
}

sub get_nvidia_smigle {
	my $smifile;
	open($smifile, "-|", $smicmd) || failure("Error opening nvidia-smi: {Error: $!}");
	return $smifile;
}

sub calc_and_set_fan {
	my @temps = @_;
	my $maxtemp = 0;
	for my $gpuid (@gpuids) {
		# Since the user's choices are indexes, they might be out of order,
		#  so the following test checks for each one they request.
		# This is not an issue, but it means you can multiple error
		#  messages for one bad read of nvidia-smi's output
		if ($#temps < $gpuid) { # gpuid expected not found in list!
			failure("List of gpuids is short! Got only " . ($#temps+1) .
				". Was looking for " . $expected_gpu_count);
		} elsif ($temps[$gpuid] < 1) {
			failure("Expected a real temperature, found $temps[$gpuid] for gpuid $gpuid");

		} else {
			$maxtemp = $temps[$gpuid] if $temps[$gpuid] > $maxtemp;
		}
	}
	print "Max temperature found: $yel$maxtemp$rst\n";
	my $pwm = calc_fan_speed($maxtemp);
}

sub	set_pwm {
	my ($pwm_enable, $pwm_value);

	my $pwm = shift;
	my %opts = @_;
	my $realtemp = $opts{temp};

	$pwm = int($pwm + .5);
	$pwm = $maxpwm if $pwm > $maxpwm;  # Just in case, crop value
	$pwm = $minpwm if $pwm < $minpwm;
	print " Setting pwm to $minpwm <= [$pwm] <= $maxpwm\n";
	if ($pwm == $last_pwm) { # No change
		print "  ${bcya}PWM value ($pwm) has not changed.$rst\n";
	} else {
		if (!open($pwm_enable, "+>", $pwm_enable_fn)) {
			failure("Take this seriously! Cannot write to PWM enable file!\n" .
				"File: {$pwm_enable_fn}  Error: {$!}", setmax=>0);
		} else {
			my $val = <$pwm_enable>;
			chomp $val;
			if ($val != 1) {
				print $pwm_enable "1\n";
				close $pwm_enable;
				pstderr("PWM not enabled ($val). Setting to 1 in file $pwm_enable_fn",
					color=>$bred,
					indent=>1);
			}
		}
		if (!open($pwm_value, ">", $pwm_fn)) {
			failure("Take this seriously! Cannot write to PWM file!\n" .
				"File: {$pwm_fn}  Error: {$!}", setmax=>0);
		} else {
			print $pwm_value "$pwm\n";
			close $pwm_value;
			if (defined $realtemp) {
				pstderr("Wrote $yel$pwm$rst to $pwm_fn (temp:${realtemp}C)");
			} else {
				pstderr("Wrote $yel$pwm$rst to $pwm_fn");
			}
			$last_pwm = $pwm;
		}
	}
}

sub calc_fan_speed {
	my $temp = shift;
	my $realtemp = $temp;
	$temp = $mintemp if $temp < $mintemp;
	$temp = $maxtemp if $temp > $maxtemp;
	print " PWM = (($maxpwm-$minpwm) * (($temp-$mintemp) / ($maxtemp-$mintemp))) + $minpwm\n";
	my $pwm = (($maxpwm-$minpwm) * (($temp-$mintemp) / ($maxtemp-$mintemp))) + $minpwm;
	set_pwm($pwm, temp=>$realtemp);
}

sub timestr_short {
	my ($sec,$min,$hour,$mday,$mon,$year) = localtime(time);
	sprintf "%04d-%d-%d %d:%d:%ds", $year+1900, $mon+1, $mday, $hour, $min, $sec;
}

while (1) {
	my $smifile = get_nvidia_smigle();
	my $select = IO::Select->new();
	$select->add($smifile);
	my $last_read = time();
	while (1) {
		$! = 0;
		print "\n== " . localtime() . " ==\n";
		my @dummy = $select->can_read($delay+1);  # Wait for "first" line of bundle
		if (scalar(@dummy) < 1) {          # timeout or error ($! is set on error)
			if ($! != 0) {
				failure("Initial can_read(1) returned an error! {Error: $!}\nWe waited $delay+1 seconds.");
			} else {
				failure("Timeout waiting for initial line from nvidia-smi: {Error: $!}\nWe waited $delay+1 seconds.");
			}
		} else {
			my @temps;
			for my $gpuid (0..$expected_gpu_count) {
				if ($select->can_read(.1)) {
					my $line = <$smifile>;
					$last_read = time();
					chomp $line;
					print " We read: $line\n" if $verbose;
					$temps[$gpuid] = int($line);
				}
			}
			print "Read temperatures: $whi", join(", ", @temps), "$rst\n";
			calc_and_set_fan(@temps);
		}
		if (time()-$last_read > $timeout) {
			failure("No reads in over $timeout seconds. Restarting nvidia-smi");
			last;
		}
	}
	close $smifile;
}

